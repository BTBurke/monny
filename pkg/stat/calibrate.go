// +build ignore

package main

import (
	"fmt"
	"log"
	"math"
	"os"
	"path"
	"sort"
	"sync"
	"text/template"
	"time"

	"github.com/BTBurke/monny/pkg/metric"
	"github.com/BTBurke/monny/pkg/rng"
	"github.com/BTBurke/monny/pkg/stat"
	numstat "gonum.org/v1/gonum/stat"
)

const (
	Loops  int     = 10000
	Run    int     = 100000
	Cap    int     = 100
	Lambda float64 = 0.25
)

var wg sync.WaitGroup

type results struct {
	mu  sync.Mutex
	val map[float64]float64
}

func (r *results) record(k float64, type1error float64) {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.val[k] = type1error
}

func newResults() *results {
	return &results{
		val: make(map[float64]float64),
	}
}

func main() {

	ct := []struct {
		name     string
		keyA     string
		keyB     string
		pdf      func() stat.PDF
		testfunc func(*results, func() stat.PDF, float64)
		kstart   float64
		kstop    float64
		kstep    float64
	}{
		{name: "Log Normal", keyA: "LogNormalA", keyB: "LogNormalB", pdf: func() stat.PDF { return stat.NewLogNormal(Cap) }, testfunc: errorRateLN, kstart: 5.0, kstop: 7.0, kstep: 0.1},
		{name: "Poisson", keyA: "PoissonA", keyB: "PoissonB", pdf: func() stat.PDF { return stat.NewPoisson(Cap, 0, metric.SampleSum) }, testfunc: errorRateP, kstart: 5.0, kstop: 7.0, kstep: 0.1},
	}

	c := make(map[string]float64)

	fmt.Println("Starting calibration.  Jet-like fans are normal as this is computationally intensive and may take a long time...")
	start := time.Now()
	for _, cc := range ct {
		res := newResults()
		for k := cc.kstart; k <= cc.kstop; k += cc.kstep {
			wg.Add(1)
			go cc.testfunc(res, cc.pdf, k)
		}
		wg.Wait()

		var keys []float64
		for k := range res.val {
			keys = append(keys, k)
		}
		sort.Float64s(keys)

		var e []float64
		for _, key := range keys {
			e = append(e, math.Log(res.val[key]))
		}
		alpha, beta := numstat.LinearRegression(keys, e, nil, false)
		c[cc.keyA] = alpha
		c[cc.keyB] = beta
		fmt.Printf("%s:  Log(error rate) = %f + %f x k\n", cc.name, alpha, beta)
	}

	pwd, err := os.Getwd()
	if err != nil {
		log.Fatalf("failed to get working directory: %v", err)
	}

	if err := generateFile(pwd, c); err != nil {
		log.Fatalf("failed to write generated file: %v", err)
	}
	fmt.Println("Generated file complete.")
	fmt.Printf("Time elapsed: %v\n", time.Since(start))
	os.Exit(0)
}

func errorRateLN(results *results, pdf func() stat.PDF, k float64) {
	defer wg.Done()
	errors := 0
	for i := 0; i < Loops; i++ {
		s, err := stat.NewEWMATestStatistic("ewma", Lambda, stat.NewFixedK(k), pdf())
		if err != nil {
			log.Fatalf("unexpected error contructing test statistic: %v", err)
		}

		t, err := stat.NewLogNormalTest(metric.NewName("calibrate", nil), stat.WithLogNormalStatistic(s))
		if err != nil {
			log.Fatalf("unexpected error constructing test statistic: %v", err)
		}
		rng := rng.NewLogNormalRNG(5.0, 1.0)

		for j := 0; j < Cap; j++ {
			if err := t.Record(rng.Rand()); err != nil {
				log.Fatalf("unexpected error recording value: %v", err)
			}
		}
		for j := 0; j < Run; j++ {
			_ = t.Record(rng.Rand())
			if t.HasAlarmed() {
				errors++
				break
			}
		}
	}
	type1error := float64(errors) / float64(Loops)
	if errors != 0 {
		results.record(k, type1error)
	}
}

func errorRateP(results *results, pdf func() stat.PDF, k float64) {
	defer wg.Done()
	errors := 0
	for i := 0; i < Loops; i++ {
		s, err := stat.NewEWMATestStatistic("ewma", Lambda, stat.NewFixedK(k), pdf())
		if err != nil {
			log.Fatalf("unexpected error contructing test statistic: %v", err)
		}

		t, err := stat.NewPoissonTest(metric.NewName("calibrate", nil), stat.WithPoissonStatistic(s))
		if err != nil {
			log.Fatalf("unexpected error constructing test statistic: %v", err)
		}
		rng := rng.NewPoissonRNG(20.0)

		for j := 0; j < Cap; j++ {
			if err := t.Record(rng.Rand()); err != nil {
				log.Fatalf("unexpected error recording value: %v", err)
			}
		}
		for j := 0; j < Run; j++ {
			_ = t.Record(rng.Rand())
			if t.HasAlarmed() {
				errors++
				break
			}
		}
	}
	type1error := float64(errors) / float64(Loops)
	if errors != 0 {
		results.record(k, type1error)
	}
}

func generateFile(dir string, c map[string]float64) error {

	f, err := os.Create(path.Join(dir, "kconst_gen.go"))
	if err != nil {
		return err
	}
	defer f.Close()

	tpl := template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was created by calibrate.go at
// {{ .Timestamp }}
// These constants are determined by monte carlo to yield a desired Type I error rate for long running statistics
package stat

const (
{{- range $key, $value := .Constants }}
	{{ $key }} float64 = {{ $value }}
{{- end }}
)
`))

	if err := tpl.Execute(f, struct {
		Timestamp time.Time
		Constants map[string]float64
	}{
		Timestamp: time.Now(),
		Constants: c,
	}); err != nil {
		return err
	}
	return nil
}
